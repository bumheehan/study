# 자바 객체지향 디자인 패턴 


# Chapter 1 : 객체지향 모델링

- 모델링은 추상화에 바탕을 두고 만들고 필요한 것만 부각

## UML
- UML(Unified Modeling Language) : 요구분석, 시스템 설계, 시스템 구현 등의 시스템 개발과정 통합 모델링 언어
- UML은 OMG(Object Management Group)에서 1997년 11월 제임스 럼버의 객체 모델링 기술 , 이바 야콥슨의 OOSE(Object Oriented Software Engineering), 그래디 부치의 OOAD(Object Oriented Analysis and Design) 방법론 등을 통합해 만들었다.
- UML 2.0에서는 구조와 동작을 표현하는 13개 다이어그램 제공

## 클래스 다이어그램
- 클래스 다이어그램은 시간에 따라 변하지않는 시스템의 정적인 면을 보여주는 대표적은 UML 구조 다이어그램이다.
- 클래스 다이어그램은 시스템을 구성하는 클래스의 관계를 보여준다.

### 클래스
 - 클래스란 동일한 속성과 행위를 수행하는 객체의 집합이다.
 - 클래스는 공통의 속성과 책임을 갖는 객체들의 집합이자 실제 객체를 생성하는 설계도다. 
 - UML 클래스 표현 
 	- 클래스이름, 속성(멤버), 연산(메소드)로 이루어져있다.
 	![Alt text](/image/uml-class.png)
 
 - 접근 제어자
	-	'+'	Public		어떤 클래스에서든 접근 가능
	-	'-'	Private		이 클래스에서 생성된 객체들만 접근 가능
	-	'#'	Protected	이 클래스와 동일한 패키지에 있거나 상속관계에 있는 하위 클래스의 객체들만 접근 가능
	-	'~'	Package		동일한 패키지에 있는 클래스의 객체들만 접근 가능

 - 관계
 	- ![Alt text](/image/uml-class-relation.png)
	 	- Association : 클래스들의 개념상 서로 연결되었습을 나타낸다. 보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일때 표시한다.
	 	- Generalization ,Inheritance : 객체지향에서 상속 관계라고 한다. 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 이를 IS-A관계라고 한다.
	 	- Composition,Aggregation : 클래스들의 상이의 전체 또는 부분 같은 관계를 나타낸다.
	 	- Dependency : 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때를 나타낸다. 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같은, 매우 짦은 시간만 유지 된다는 점이다.
	 	- Realization : 책임들의 집함인 인터페이스와이 책임들을 실제로 실현한 클래스들 사이의 관계를 나타낸다.
 	
 	- 연관(Association) :
 		1. 학생클래스 S , 수업클래스 C
 			- S 일 대 다 C : 다수의 Course에 Student 한명씩 들을 수 있다.
 			- S 다 대 다 C : 다수의 course에 다수의 Student가 들을 수 있다.
 		2. 학생클래스 S , 수업클래스 C, 성적클래스 T : A학생의 C수업의 성적은 T입니다.
 			- S 일 대 다 T 다 대 일 C : 한명의 학생당 여러개의 성적을 받을수 있다. 그리고 마찬가지로 한개의 수업당 여러개의 성적을 낼수 있다.
 			
 	- 상속(Inheritance):
 		- 슈퍼클래스(부모)와 서브클래스(자식)의 관계
 		- 자동차(super) , 아반떼(sub), 소나타(sub)의 관계
 		- 아반떼는 자동차의 한 종류 이다, 소나타는 자동차의 한 종류이다.
 		
	- 집합(Composition,Aggregation):
 		1. Composition
 			- A라는 객체를 생성할때 생성자에서 B,C,D,E객체를 생성 할 경우 A라는 객체가 없어지면 자동으로 B,C,D,E객체도 사라진다.
 			<pre><code>
 			Public class A{
 				private B b;
 				private C c;
 				private D d;
 				private E e;
 				
 				public A(){
 					this.b = new B();
 					this.c = new C();
 					this.d = new D();
 					this.e = new E();
 				}
 			}
 			</code></pre>
 		2. Aggregation
 			- A라는 객체를 생성할때 생성자에서 B,C,D,E를 참조받으면 A객체가 없어져도 B,C,D,E 객체는 남아있다.
 			<pre><code>
 			Public class A{
 				private B b;
 				private C c;
 				private D d;
 				private E e;
 				
 				public A(B b,C c,D d,E e){
 					this.b = b;
 					this.c = c;
 					this.d = d;
 					this.e = e;
 				}
 			}
 			</code></pre>
 	- 의존(Dependency) :
 		- 연관 관계는 오랜 시간 동안 같이할 객체와의 관계이며 의존관계는 짧은 시간 동안 이용하는 관계이다.
 		- 의존 관계는 A라는 객체의 메소드를 실행할 때 매개변수로 B 클래스의 객체를 참조하는 관계이다. 
 		
 	- 실체화 단계(Realization)
 		- 인터페이스란 책임이다. 어떤 객체의 책임이란 객체가 '해야 하는 일'로서 해석할 수 있고 어떤 경우에는 객체가 '할 수 있는 일'로도 해석할 수 있다.
		- 일반화 관계는 'is a kind of'관계이고 실체화 관계는 'can do this' 관계이다.

		
# Chapter 2 : 객체 지향 원리

## 추상화

## 캡슐화
- 캡슐화 : 객체의 속성과 메소드를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다. 은닉정도는 접근지정자로 지정한다.
- 결합도 : 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타내는 지표, 결합도가 높을 경우 연관된 다른 클래스의 변화에 민감하다.
- 응집도 : 클래스나 모듈안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 지표, 다시말해서 많은 기능을 할 수록 응집도는 낮아지고 적은 기능을 할때 높아진다. 예를들어 이미지 처리와 사운드 처리를 같이하는 클래스일 경우 응집도가 낮다.
- 높은응집도, 낮은 결합도로 설계해야 요구사항을 변경할때 유리
- 캡슐화는 정보은닉을 통해 높은 응집도와 낮은 결합도를 갖도록 한다.
- 정보은닉이란 알 필요 없는 정보는 외부에서 접근하지 못하도록 제한하는것 예를 들어 자동차를 움직일때 어떠한 과정을 거치는지 모르더라도 운전하는데 지장이 없다.

## 일반화의 관계(Generalization) 
 - 일반화의 관계는 객체지향 관점에서 상속관계라고 함
 - 배,사과,키위를 일반화시키면 과일임, 반대로 과일에서 배,사과 키위로 가는 것을 특수화(Specialization)임
 - 
## 다형성
- 서로다른 클래스의 객체가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력
- 예를 들어 동물 추상 클래스에서 추상 메소드인 talk를 새,사자,사람 등 여러 자식 클래스에서 따로 구현하는것
- static 메소드는 오버라이딩 안됨.

# Chapter 3 : SOLID 원칙

## 단일 책임 원칙
 - 소프트 웨어 첫 번째 원칙으로ㅓ SRP(Single Responsibility Principle)라는 단일 책임 원칙이 있다.

### 책임
 - SRP에서 말하는 책임의 기본단위는 객체를 자칭 => 객체는 단 하나의 책임만 가져야 한다.
 - 책임 : 보통 '해야 하는 것'이나 '할 수 있는 것'으로 간주
 - 결합도를 낮추려면 하나의 클래스에는 하나의 책임(기능)만 수행하도록 해야한다.
 
### 산탄총 수술
 - 여러클래스가 하나의 책임을 다룰때 SRP에 입각해 설계변경해야하는 경우도 있다. = > 산탄총 수술이라고 표현한다.
 - 동물이 산탄총 맞을때 여러곳(클래스)를 수술(변경)해야한다는 점에서 착안됨.
 - 하나의 책임을 여러개의 클래스로 분리되어 있는 대표적인 예는 로깅,보안,트랜잭션 등 과 같은 횡단 관심(Cross-Cutting Concern)
 - 해결방법 : 로그기능을 사용하고 부가기능은 별개 클래스로 분리

### AOP(Aspect-Oriented Programming)
 - 대충 설명되어있는데 나중에 자세히 공부 
 - 관심지향 프로그래밍
 - <a href="https://addio3305.tistory.com/86"> 참조 </a>
 - 로깅같이 여러군데서 사용하는 기능을 따로 빼내서 하나의 부가기능으로만들고 필요할때마다 삽입하는 프로그래밍인가봄 
 - 용어만 따로정리
 	- 조인포인트 : AOP를 사용해 삽입할 시점
 	- 어드바이스 : 조인하는 코드
 	- 포인트컷 : 여러 조인포인트 집합체
 	- Aspect : 어드바이스 + 포인트컷 
 	- 위빙 : Aspect 주입과정
 - 나중에 Spring 에서 사용해봐야할듯
 
 
# Chapter 4 : 디자인 패턴
 
	- GoF 디자인 패턴 : 에리히 감마, 리차드 헬름, 랄프 존슨 , 존 블리시디스는 소프트웨어영역에서 디자인 패턴을 구체화하고 체계화한 GoF(Gang of Four)라 불리는 사람들의 이름이다. 이들은 디자인패턴 23가지를 정리하고 생성,구조,행위의 3가지로 분류했다.

### 생성 패턴 : 객체의 생성과 조합
	- 추상 팩토리
	- 빌더
	- 팩토리 메서드
	- 프로토타입
	- 싱글턴
###  구조패턴 : 클래스나 객체를 조합해 더큰 구조로 만드는 패턴
	- 어댑터
	- 브릿지
	- 컴퍼지트
	- 데커레이터
	- 퍼샤드
	- 플라이웨이트
	- 프록시
### 행위패턴 : 객체나 클래스 사이의 알고리즘이나 책임분배에 관련된 패턴
	- 책임연쇄
	- 커맨드
	- 인터프리터
	- 이터레이터
	- 미디에이터
	- 메멘토
	- 옵저버
	- 스테이트
	- 스트래티지
	- 펨플릿 메서드
	- 비지터
	

## UML과 디자인패턴
	- 순차다이어그램 : 행위
	
<hr/>

# Chapter 5 : 스트래티지 패턴
	- Strategy 패턴은 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화 되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.
	
# Chapter 6 : 싱글턴
	- Singleton 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 이 인스턴스에 접근할 수 있도록 하는 디자인 패턴이다
	- Client는 정상, Client2는 동기화안할경구 문제
	
# Chapter 7 : 스테이트 패턴
	- State 패턴은 외부 객체(클라이언트)의 개입없이 컨텍스트의 멤버인 스테이트 객체를 변경, 각 상태를 객체화
	- Strategy 패턴과 차이점
		 - 두 패턴은 비슷한데 컨텍스트의 멤버인 상태 객체를 외부 객체로 변경되는지(Strategy), 외부 객체 없이 스스로 변경되는지(State)에 따른 차이점이있다.

# Chapter 8 : 커맨드 패턴
	- Command 패턴은 이벤트가 발생했을 때(invoke) 이벤트 클래스를 변경하지 않고 다양한 명령(Command1,2,3..)을 내리기 위해 사용한다.
	- 커맨드 패턴은 수신자와 호출자의 의존성을 제거한다.
	- Java Swing에서 이벤트 객체가 커맨드 객체이다.
	- 위키 : 커맨드 패턴에는 명령(command), 수신자(receiver), 호출자(invoker), 클라이언트(client)의 네개의 용어가 항상 따른다. 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행한다. 커맨드 객체는 별도로 발동자 객체에 전달되어 명령을 호출하게 한다. 호출자 객체는 필요에 따라 명령 호출에 대한 기록을 남길 수 있다. 한 호출자 객체에 다수의 커맨드 객체가 전달될 수 있다. 클라이언트 객체는 호출자 객체와 하나 이상의 커맨드 객체를 보유한다. 클라이언트 객체는 어느 시점에서 어떤 명령을 수행할지를 결정한다. 명령을 수행하려면, 클라이언트 객체는 호출자 객체로 커맨드 객체를 전달한다.